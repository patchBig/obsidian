## 背景

WebAssembly——它又称作 WASM。为什么有这样的实践？因为 WASM 运行速度比 JS 快，想要极致的用户体验？Sorry，尝试加任务罢了。

目的是将算法同学基于 MNN 实现姿态识别算法、动作计数算法的 C++ 代码转译成 WASM，使其在浏览器端也能实现和端上同样的功能。现阶段，各端动作计数的实现不一，统一起来难度较大。相比于客户端，h5 天然就能运行在各个客户端内，能够进行统一的迭代更新。另一方面也能帮助业务快速进行产品迭代、更新以及试错。

## 说明

WASM 设计之初不是为了手写代码，它为多种低级源语言提供编译目标，如 C/C++、C# 和 Rust 代码，在浏览器中以接近原生的性能运行。暴露出的 WASM 函数供 JavaScript 调用，获得性能提升。提供了一个沙盒执行环境，拥有像存储、安全性等功能，能够用来执行从另一种语言编译过来的代码。

它是一种类似于汇编的低级语言，具有严谨的二进制格式，是一种**虚拟指令集架构**（*virtual instruction set architecture, virtual ISA*）。WASM 能在非浏览器、JS 环境中执行，完全不依赖 web 环境，所以能在嵌入式系统、物联网等其它环境中应用。

## 优势

1. **性能**，WASM 提供了接近 native 的性能，意味着它的运行速度能和 native 相提并论。因为它是字节码格式的，能够在现代浏览器中更快的加载以及高效执行。
2. **跨平台**，WASM 能够运行在任何支持它的平台上，包括且不限于浏览器，服务器以及其它平台
3. **与语言无关**，只要能被编译成 WASM，像 C++、Rust、TS。这样的话，开发人员就能尽情使用自己喜欢的语言，同时还能拥有 WASM 的优势
4. **安全**，WASM 运行在一个沙盒环境中，意味着对于系统的其它部分，它是独立运行的。不会操作和影响敏感数据。所以在浏览器中运行不信任的代码，相对比较安全。
5. **更小**，相比于其它的 web 技术，因为 WASM 文件更小，所以它的下载和执行更快，性能也就更好

## 劣势

1. **debugging**，相对于 web 其它技术，在 WASM 中进行调试代码还是比较困难的。缺少标准的 debugging 功能。开发者必须要依赖浏览器的 console 或者特定的调试工具去发现和修改代码中的错误。这里推荐下 Chrome 插件 *C/C++ DevTools Support (DWARF)* ，能够在浏览器中调试 C++ 代码
   ![[Pasted image 20230225172616.png]]

 2. **字节码文件的大小**，相对于其它的 web 技术，通常 WASM 文件是比较小的，对于一些复杂的应用，它仍然比较大。会占用较长的下载时间和内存的使用。这就可能需要我们在使用这些文件时，需要缓存在本地
3. **浏览器的限制**，虽然已经在大多数主流浏览器中得到了支持，但是还有一小部分不常用的浏览器还没支持 WASM，会影响已经使用 WASM 技术的应用。
4. **手动垃圾收集**，对于习惯使用 JS 的自动回收垃圾机制的前端开发，在使用 WASM 时，需要我们手动申请内存空间，并且在使用完毕后，手动释放内存空间
5. **不能直接访问 DOM**，需要借助 JS 才能进行 DOM 的操作，通过在 C++ 或其他语言中嵌入并执行 JS 代码，才能进行间接访问

## 应用场景

WASM 有着广泛的应用场景

- 